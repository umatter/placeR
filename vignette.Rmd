---
title: "Introduction to the placeR package"
author: "Ulrich Matter"
date: "January 17, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Set Up

Install and load the package:
```{r message=FALSE, warning=FALSE}
library(devtools)
#devtools::install_github("umatter/placeR")
#library(placeR)
devtools::load_all()
```

The package's request functions expect a variable `api.key` with the Google Places API Key stored in it in the global environment.
```{r message=FALSE, warning=FALSE}
api.key <- readLines("_misc/key")[1]
```


## Example of simple searches

### Search Restaurants in New York

Search restaurants in a given radius around specific coordinates with `searchNearby()`.
```{r message=FALSE, warning=FALSE}
nyrest <- searchNearby(location="40.7,-74.0", radius=5000, types="restaurant")
```

Inspect the results. The formatted data can be extracted via `placesData()`. 
```{r message=FALSE, warning=FALSE}
# check the class of the returned object
class(nyrest)

# extract and inspect data
ny <- placesData(nyrest)
dim(ny)
str(ny)
ny[1:3,1:4]
```

Or we can plot the results via the plot method for objects of class "`placesearch`":
```{r message=FALSE, warning=FALSE}
library(ggmap)
register_google(api.key)
plot(nyrest, ggmap.zoom=12)
```

## Large area searches

### Detailed example, step by step

Define the search parameters. Two points (coordinates) define the bounding box.
```{r message=FALSE, warning=FALSE}
sa <- c(5.5, 11, 45.5, 48)
a.df <- as.data.frame(matrix(data=sa, nrow=2, ncol=2))
names(a.df) <- c("x","y")
```

Set the radius of each individual radar search
```{r message=FALSE, warning=FALSE}
r=50000
```

Compute search points for searchRadar. That is, at which points of the overall area should a radar search be executed.
```{r message=FALSE, warning=FALSE}
sdlpoints <- getPointsArea(area=a.df, radius=r)
sdllocs <- locations(sdlpoints)
```


Extract the references to each place/location for the detail search, and execute the details search
```{r message=FALSE, warning=FALSE}

# Not yet implemented
# refstest <- na.omit(as.character(sdltest$reference))
# # search details to the references
# details_test <- placeDetails(reference=refstest[1:150],
#                              saveDL=TRUE, 
#                              chunksize=10) 

```


### Example preparation of areaScan
```{r message=FALSE, warning=FALSE}
# example of search: scan all switzerland
library(sp)
cantons <- readRDS(url("https://biogeo.ucdavis.edu/data/gadm3.6/Rsp/gadm36_CHE_1_sp.rds")) 

# extract map edges
edges <- getEdges(x=cantons) 

# plot search area
area <- getPointsArea(edges, radius=20000)
plot(area)
```


### Extended example to demonstrate areaScan
The goal of the exercise is to get information on 'all' churches in a canton.

First, load the respective shapefile with the Swiss administrative borders and select one canton.
```{r message=FALSE, warning=FALSE}
bs <- cantons[cantons$NAME_1=="Basel-Stadt",] 
```

Run the area scan. Note that due to the depriciation of the API's radar search function, the results are restricted to 20 (60 if going to next page).
```{r message=FALSE, warning=FALSE}
# extract map edges
edges <- getEdges(x=bs) 
# run the scan
scanresp <- areaScan(area=edges, radius=3000, types="church", details=FALSE )
```

Extract, clean, and have a look at the data...
```{r message=FALSE, warning=FALSE}
data <- placesData(scanresp)
data <- data[!duplicated(data$id),]
plot(scanresp, ggmap.zoom=12, ncircles=6)
```



## Religious fragmentation case study

We use the Google Places API in order to identify places of worship in Swiss cities. In order to identify the search areas we need suggest the following generalizable approach to define cities/urban areas (independent of juristictional borders).

1.  In a first step, we import raster data indicating settlements around the globe from the European Commission's [GHS SETTLEMENT GRID (LDS)](https://ghslsys.jrc.ec.europa.eu/ghs_smod.php).
2. We crop the raster area of the country under analysis based on the country's [GADM](https://gadm.org/) shapefile.
3. The country raster is converted into polygons, keeping only the outer borders. This results in polygons of the country's settled/urban areas.
4. Each polygon of an urban area (island) is extracted as an individual feature.
5. By overlaying the extracted urban areas with [Harvard WorldMap's Placemarks data](http://worldmap.harvard.edu/data/geonode:placemarks_edited_columns_yz6), we assign to each urban area the name, id, and additional metadata of the city with the largest population falling into the respective area.

The following Figure illustrates the procedure for Switzerland.

```{r message=FALSE, warning=FALSE, echo=FALSE}
# first get the cities polygons
PATH <- "_misc/GHS_SMOD_POP2015_GLOBE_R2016A_54009_1k_v1_0/GHS_SMOD_POP2015_GLOBE_R2016A_54009_1k_v1_0.tif"
# run steps 1-4
poly <- getCountryCities(PATH, country="SWITZERLAND", tol=0.01, intermediate = TRUE)

# run step 5
# load cities from http://worldmap.harvard.edu/data/geonode:placemarks_edited_columns_yz6
markers <- "_misc/placemarks_edited_columns_yz6/placemarks_edited_columns_yz6.shp"
poly$cities <- addCityNames(poly$cities, markers)

# plot the results
par(mfrow=c(2,2))
plot(poly$settlement_raster, main="Settlement raster")
plot(poly$country_raster, main="Settlements within country")
plot(poly$city_raster, main="Cities within country")
plot(poly$country, add = TRUE)
plot(poly$cities, main="Identified city polygons", border="steelblue")
plot(poly$country, add = TRUE)


```


As a result, we can identify the metropolitan areas/cities, and merge additional information.
```{r echo=FALSE, message=FALSE, warning=FALSE}
cities <- poly$cities
# plot with labels (taken from https://stackoverflow.com/a/5144951)
sp.label <- function(x, label) {
    list("sp.text", coordinates(x), label)
}

city.sp.label <- function(x) {
    sp.label(x, x$asciiname)
}


spplot(cities,
       main="Urban areas in Switzerland",
       zcol = "area",
       sp.layout = city.sp.label(cities),
       auto.key = list(title = "Area"))
```

Based on this, we can gather for each city polygon the places of worship with the following procedure:

1. Extract all city polygons per country.
2. For each city polygon in each country, divide the polygons' bounding boxes into a grid of square cells. The squares' size is defined by radius parameter of the [Google Places API's Nearby Search Method](https://developers.google.com/places/web-service/search) as per the following rationale:
  - Each Nearby Search request returns up to 60 places of interest (fitting certain keywords) within a given `radius` ($r$) of a given point on the globe (long/lat-coordinates, $c_{i}$). 
  - In order to cover the entire bounding box of a city polynomial, we have to derive the coordinates $c_{i}$ based on which searches for places via the Places API cover the entire area of the box, given $r$ (which essentially defines the granularity of the search results).
  - To do so, we first compute the length $a$ of the side of the square that has a diagonal equal to $2\times r$: $a=\sqrt{(2\times r)^{2}/2}$. Then, we divide the box into squares of lenght $a$ from top-left to bottom-right.
  - Finally, we calculate the destination points that mark the center of each of these squares ($c_{i}$), traveling along the rhumb line from square cell to square cell (direction left to right, for each 'row')  with distance $a/2$ from the grid lines.
3. We call the API's Nearby Search method for each coordinate $c_{i}$, extracting all (up to) 60 search results.
4. Based on the search results for each city polygon, we compute the *Fragmentation Index*.

The following figure and table illustrate the procedure for the case of the canton of Basel-Stadt (input: polygon of the official cantonal borders).


```{r echo=FALSE,  message=FALSE, warning=FALSE}
plot(scanresp, ggmap.zoom=12, ncircles=6)
```
The black lines indicate the bounding box of the input polygon (cantonal borders). The blue circles and cross hairs indicate the Nearby Search area/radius and the search coordinates, respectively. The small red circles indicate the search results (for place type `"church"`). The following table shows the details of the first few search results

```{r}
library(knitr)
kable(data[1:10, 1:6])

```

